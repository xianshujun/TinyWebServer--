# 文件结构详解
![图片](https://github.com/user-attachments/assets/309615d2-a646-41a3-a488-d5a7260c9f0b)
## CGImysql
该文件主要是mysql相关的模块与组件。

简单说一下什么是数据库连接：应用访问数据库时会建立一个连接。这个过程会与数据库的服务器进行网络通信，验证身份等。而每次打开和关闭数据库连接很耗时
所以出现了数据库连接池：可以减少开销提升速度，控制并发，总之，有很多好处。

想象一下你在一个游泳馆里租借游泳圈。如果你每次都去购买新的游泳圈，那会非常浪费时间并且成本很高。相反，游泳馆提供了一堆已经准备好的游泳圈供游客使用。当你需要游泳圈时，你就从这个“游泳圈池”中拿一个；当你不再需要时，就把游泳圈放回池子里，以便其他人可以使用。

那么数据库连接池主要有几个阶段，一个是创建一组预定义的数据库连接，然后存起来（可以存到数组里，列表里，反正先存起来）
当有想要访问数据库的时候，不创建数据库连接，而是从刚刚存的池子里面取一个可用的连接
接下来用这个连接完成一系列工作
完成后不关闭，而是归还给池子。大致是这么回事
有的高级一些的池子还有动态管理，有效管理啥的，可以根据需求动态的调整连接的数量

## http
封装了http协议的基本功能，用来处理通信的

由于有了这些封装，开发人员可以不用自己手写一个，会方便一些。至于什么是http协议，tcp/icp协议的细节嘛，自己去看计算机网络，或者网搜一下

## lock
线程同步机制包装类，主要用来实现互斥访问，多线程同步的

这个东西，学操作系统的时候应该是有了解的。什么叫做线程同步，简单的来说，假设a和b同时想要上厕所，但只有一个坑，那他俩总不能挤在一起上吧。所以就需要一套规则用来协调他俩。这是临界区的情况，还有比如说生产者消费者的情况等，也都类似。自己网上搜一下，一定要弄明白。不然影响你后面写代码

## log
日志系统，就是用来记录运行信息的。
这里有同步日志和异步日志两种方式。什么是同步日志呢？什么又是异步日志呢？通俗点说，同步就是某条程序运行完，就记下来存到笔记本里。所以程序每生成一条
日志消息的时候，就会立即停止正在执行的任务。很容易实现，但也会导致性能下降。而且频繁的读写磁盘，如果 磁盘或者说固态硬盘的速度跟不上，怎么办？那就会成为瓶颈。（尤其是很多高并发的时候，比如说选课的时候上万人同时选某几门课）
异步日志则是把日志消息放到一个队列或者说缓冲区里面，然后有一个单独的线程或几个线程来定时从里面取消息放到磁盘里。所以不需要频繁的读写磁盘。两者各有优劣。

## root
这个没什么好说的，里面放了一些html文件还有图片啥的。

## test_pressure
压力测试，用来测试网站性能的

## threadpool
什么叫做同步io模拟proactor模式，举个例子：
    传统的同步方式：你开始煮一锅汤，然后站在锅旁边等着，直到汤煮好才能去做其他的事情。
    真正的Proactor方式：你设置了一个计时器，告诉计时器在汤煮好后响铃提醒你。在这期间，你可以自由地做别的家务。
    同步IO模拟Proactor：你请了一个帮手（线程）帮你盯着锅。你告诉他，一旦汤煮好了就叫你（回调）。这样，你仍然可以去做别的家务，虽然实际上还是有人在同步地等待汤煮好，但从你的角度来看，效果和Proactor很相似。
什么叫做半同步/半反应堆呢，举个例子：
    你经营着一家小餐馆，顾客不断进来点餐。为了处理这些订单，你可以采用一种结合了传统服务方式和现代高效管理技巧的方法，这就是“半同步/半反应堆”模式。
同步部分（半同步）：
    接待员：你站在门口，负责迎接每一位进来的顾客，并记录下他们的订单。
    立即响应：每当有新顾客进来时，你会立即停下手中的事情去接待他们，记录下他们的需求。这个过程是同步的，因为你必须立刻响应新的请求。

反应堆部分（半反应堆）：
    厨师团队：厨房里有几个厨师，他们随时准备根据你的指令开始做菜。
    异步处理：你把顾客的订单交给厨房里的厨师，然后继续回到门口迎接新的顾客。厨师们在后台做饭，不需要你的持续关注。当饭菜做好后，他们会通知你。
    事件驱动：你在门口等待，同时注意是否有新的顾客进来，以及是否有饭菜已经准备好需要你送出去。这种等待多个事件发生的机制就是反应堆的一部分。

结合起来：
    半同步：你作为接待员，需要立即响应每个新进来的顾客，这是同步的部分。
    半反应堆：一旦你记下了顾客的订单，你就把它交给厨房的厨师去处理，而你自己则继续迎接新的顾客。厨师完成任务后会通知你，这是反应堆的部分。

线程我上面说过了，但是没说线程池，那线程池是什么意思呢？看一下线程池的定义：线程池是一种多线程处理形式，它预先创建一组线程，并将这些线程保持在就绪状态，以便随时可以执行任务。当有新的任务需要处理时，线程池会从这组线程中选择一个空闲的线程来执行该任务。任务完成后，线程不会被销毁，而是返回到线程池中等待下一个任务。  有没有发现，跟我们前面讲的数据库连接池很像是不是。其实他俩确实是差不多。不过这里复用的是线程，上面复用的是连接。

## timer




    



